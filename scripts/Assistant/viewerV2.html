<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>GLB Viewer mit Three.js</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/three/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.js"></script>

  <script>
    let scene, camera, renderer, controls;

    function init() {
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0.73, 1.6);

      renderer = new THREE.WebGLRenderer({antialias: true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x2e2e2e);
      document.body.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 10, 7);
      scene.add(directionalLight);

      const loader = new THREE.GLTFLoader();
      loader.load(
        "./models/AppearanceMikuBlender.glb",
        function(gltf) {

            scene.add(gltf.scene);

            // Animationen laden und Mixer erstellen
            if (gltf.animations && gltf.animations.length) {
                mixer = new THREE.AnimationMixer(gltf.scene);

                // Erste Animation abspielen
                const action = mixer.clipAction(gltf.animations[0]);
                action.play();
            }
          // Material-Fixes
          gltf.scene.traverse((child) => {
            if (child.isMesh) {
                /*console.log("Mesh Name:", child.name);
                console.log("Material Name:", child.material.name);*/
              let mat = child.material;

              //Meine inkompetenz mit Blender in Code gefixed :J
              if (mat.opacity === 1) {
                mat.transparent = true;
                mat.alphaTest = 0.5; // Literally
                mat.depthWrite = false;
              } else {
                  mat.transparent = false;
                }
              mat.depthWrite = true;
              mat.depthTest = true;

              // 🔹 Encoding-Warnung beheben
              if (mat.map) {
                mat.map.colorSpace = THREE.SRGBColorSpace;
              }

              // 🔹 Namen bereinigen (gegen Shader-Fehler)
              if (child.name) {
                child.name = child.name.replace(/[^\x00-\x7F]/g, "_");
              }
            }
          });

          scene.add(gltf.scene);
          console.log("✅ GLB-Modell geladen");
        },
        function(xhr) {
          console.log(`Ladefortschritt: ${(xhr.loaded / xhr.total * 100).toFixed(2)}%`);
        },
        function(error) {
          console.error("❌ Fehler beim Laden:", error);
        }
      );

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    init();
    animate();
  </script>
</body>
</html>
